PartType Promoter;
PartType Insulator;
PartType RBS;
PartType CDS;
PartType Terminator;

CDS HlyIIRjs;
CDS PhlF;
CDS SrpR;
CDS output_YFP;
Insulator RiboJ10;
Insulator RiboJ51;
Insulator RiboJ53;
Promoter pTac;
Promoter pTet;
Promoter pHlyIIR;
Promoter pPhlF;
Promoter pSrpR;
RBS an2_srpr;
RBS js2_hlyiir;
RBS js2_phlf;
Terminator ECK120029600;
Terminator ECK120033736;
Terminator ECK120033737;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//This works correctly, however, it fixes the promoter order. Our goal is to allow any promoter order
//
//Device gate_NOR_js2_PhlF(pSrpR,pHlyIIR,RiboJ53,js2_phlf,PhlF,ECK120033737);
//Device gate_NOR_js2_HlyIIR(pTet,RiboJ51,js2_hlyiir,HlyIIRjs,ECK120033736);
//Device gate_NOR_an2_SrpR(pTac,RiboJ10,an2_srpr,SrpR,ECK120029600);
//Device gate_output_YFP(pPhlF,output_YFP);
/////////////////////////////////////////////////////////////////////////////////////////////////////

//NOR gate, two promoters
Device gate_NOR_js2_PhlF(Promoter,Promoter,RiboJ53,js2_phlf,PhlF,ECK120033737);
Rule promoter_order_1(ON gate_NOR_js2_PhlF:
 CONTAINS pSrpR AND
 CONTAINS pHlyIIR AND
 NOT FORWARD pSrpR OR pSrpR BEFORE pHlyIIR AND
 NOT REVERSE pSrpR OR pSrpR AFTER  pHlyIIR AND
 //AND
 //all parts SAME_ORIENTATION
 //part order should reverse if the Device is in the reverse orientation
);

//NOT gate, one promoter
Device gate_NOR_js2_HlyIIR(Promoter,RiboJ51,js2_hlyiir,HlyIIRjs,ECK120033736);
Rule promoter_order_2(ON gate_NOR_js2_HlyIIR:
 CONTAINS pTet
 //AND
 //all parts SAME_ORIENTATION
 //part order should reverse if the Device is in the reverse orientation
);

//NOT gate, one promoter
Device gate_NOR_an2_SrpR(Promoter,RiboJ10,an2_srpr,SrpR,ECK120029600);
Rule promoter_order_3(ON gate_NOR_an2_SrpR:
 CONTAINS pTac AND
 //AND
 //all parts SAME_ORIENTATION
 //part order should reverse if the Device is in the reverse orientation 
);

//output gate, one promoter
Device gate_output_YFP(pPhlF,output_YFP);

Device logic_gates(
gate_NOR_js2_PhlF, 
gate_NOR_js2_HlyIIR, 
gate_NOR_an2_SrpR, 
gate_output_YFP);

Rule logic_gate_rules(ON logic_gates:
gate_NOR_js2_PhlF exactly 1 AND
gate_NOR_js2_HlyIIR exactly 1 AND
gate_NOR_an2_SrpR exactly 1 AND
gate_output_YFP exactly 1 AND
ENDSWITH gate_output_YFP AND
FORWARD gate_output_YFP AND
ALTERNATE_ORIENTATION

//Ideally, it would also be fantastic to say "NOT TERMINATOR NEXTTO PROMOTER" at this level as a second way to specify ALTERNATE_ORIENTATION.  However, this rule is actually more important for the flat design.  In my flat design, only rules based on Part names were enforced, rules based on PartTypes were not enforced.  This was problematic because I had to enumerate every combination of Promoter:Terminator pairs and say "NOT p1 NEXTTO t1", "NOT p1 NEXTTO t2", "NOT p1 NEXTTO t3", etc.

);


result = permute(logic_gates);
